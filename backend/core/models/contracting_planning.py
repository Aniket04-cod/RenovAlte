from django.db import models
from .project import Project


class ContractingPlanning(models.Model):
	"""
	Store custom contracting requirements and uploaded documents
	"""
	project = models.OneToOneField(
		Project,
		on_delete=models.CASCADE,
		related_name='contracting_planning'
	)
	description = models.TextField(
		"Description",
		help_text="Description of specific contracting needs"
	)
	
	# AI-generated insights
	ai_summary = models.TextField(
		"AI Generated Summary",
		blank=True,
		null=True,
		help_text="AI-generated summary of the project"
	)
	ai_questions = models.JSONField(
		"AI Generated Questions",
		blank=True,
		null=True,
		help_text="Questions generated by AI to clarify requirements"
	)
	user_answers = models.JSONField(
		"User Answers",
		blank=True,
		null=True,
		help_text="User's answers to AI-generated questions"
	)
	selected_contractors = models.JSONField(
		"Selected Contractors",
		blank=True,
		null=True,
		help_text="Array of contractor IDs selected for invitation"
	)
	current_step = models.IntegerField(
		"Current Step",
		default=1,
		help_text="Current step in the contracting workflow (1-4)"
	)
	
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)

	class Meta:
		verbose_name = "Contracting Planning"
		verbose_name_plural = "Contracting Plannings"

	def __str__(self):
		return f"Planning for {self.project.name}"


class ContractingPlanningFile(models.Model):
	"""
	Store files uploaded for contracting planning
	"""
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='files'
	)
	file = models.FileField(
		upload_to='contracting_planning/%Y/%m/%d/',
		help_text="Uploaded document or photo"
	)
	filename = models.CharField(max_length=255)
	uploaded_at = models.DateTimeField(auto_now_add=True)

	class Meta:
		verbose_name = "Contracting Planning File"
		verbose_name_plural = "Contracting Planning Files"

	def __str__(self):
		return f"File for {self.contracting_planning.project.name}"


class SentEmail(models.Model):
	"""
	Track emails sent to contractors
	"""
	STATUS_CHOICES = [
		('pending', 'Pending'),
		('sent', 'Sent'),
		('failed', 'Failed'),
	]
	
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='sent_emails'
	)
	contractor_email = models.EmailField(
		"Contractor Email",
		help_text="Email address of the contractor"
	)
	subject = models.CharField(
		"Email Subject",
		max_length=500,
		help_text="Subject line of the email"
	)
	body_html = models.TextField(
		"Email Body HTML",
		help_text="HTML content of the email body"
	)
	sent_at = models.DateTimeField(
		"Sent At",
		auto_now_add=True,
		help_text="Timestamp when the email was sent"
	)
	gmail_message_id = models.CharField(
		"Gmail Message ID",
		max_length=255,
		blank=True,
		null=True,
		help_text="Message ID from Gmail API"
	)
	gmail_thread_id = models.CharField(
		"Gmail Thread ID",
		max_length=255,
		blank=True,
		null=True,
		help_text="Thread ID from Gmail API"
	)
	status = models.CharField(
		"Status",
		max_length=20,
		choices=STATUS_CHOICES,
		default='pending',
		help_text="Status of the email sending"
	)
	error_message = models.TextField(
		"Error Message",
		blank=True,
		null=True,
		help_text="Error message if sending failed"
	)
	
	class Meta:
		verbose_name = "Sent Email"
		verbose_name_plural = "Sent Emails"
		ordering = ['-sent_at']
	
	def __str__(self):
		return f"Email to {self.contractor_email} - {self.status}"


class Message(models.Model):
	"""
	Store conversation messages between user and AI agent for each contractor
	"""
	SENDER_CHOICES = [
		('user', 'User'),
		('ai', 'AI Agent'),
		('contractor', 'Contractor'),
	]
	
	MESSAGE_TYPE_CHOICES = [
		('user', 'User Message'),
		('ai', 'AI Response'),
		('ai_action_request', 'AI Action Request'),
		('ai_action_executed', 'AI Action Executed'),
	]
	
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='messages'
	)
	contractor_id = models.IntegerField(
		"Contractor ID",
		help_text="ID of the contractor this conversation is with"
	)
	sender = models.CharField(
		"Sender",
		max_length=20,
		choices=SENDER_CHOICES,
		help_text="Who sent this message"
	)
	message_type = models.CharField(
		"Message Type",
		max_length=30,
		choices=MESSAGE_TYPE_CHOICES,
		default='user',
		help_text="Type of message for rendering purposes"
	)
	content = models.TextField(
		"Message Content",
		help_text="The text content of the message"
	)
	timestamp = models.DateTimeField(
		"Timestamp",
		auto_now_add=True,
		help_text="When the message was sent"
	)
	
	class Meta:
		verbose_name = "Message"
		verbose_name_plural = "Messages"
		ordering = ['timestamp']
		indexes = [
			models.Index(fields=['contracting_planning', 'contractor_id', 'timestamp']),
		]
	
	def __str__(self):
		return f"{self.sender} message to contractor {self.contractor_id} at {self.timestamp}"


class MessageAction(models.Model):
	"""
	Store actions that AI agent wants to perform on behalf of the user
	"""
	ACTION_TYPE_CHOICES = [
		('send_email', 'Send Email'),
		('draft_email', 'Draft Email'),
	]
	
	ACTION_STATUS_CHOICES = [
		('pending', 'Pending User Approval'),
		('approved', 'Approved'),
		('rejected', 'Rejected'),
		('executed', 'Executed'),
		('failed', 'Failed'),
	]
	
	message = models.OneToOneField(
		Message,
		on_delete=models.CASCADE,
		related_name='action',
		help_text="The message this action is associated with"
	)
	action_type = models.CharField(
		"Action Type",
		max_length=20,
		choices=ACTION_TYPE_CHOICES,
		help_text="Type of action to perform"
	)
	action_status = models.CharField(
		"Action Status",
		max_length=20,
		choices=ACTION_STATUS_CHOICES,
		default='pending',
		help_text="Current status of the action"
	)
	action_data = models.JSONField(
		"Action Data",
		help_text="Action-specific data (e.g., email subject, body, recipient)"
	)
	action_summary = models.TextField(
		"Action Summary",
		help_text="Human-readable summary for conversation context"
	)
	execution_result = models.JSONField(
		"Execution Result",
		blank=True,
		null=True,
		help_text="Results after action execution (e.g., Gmail message_id)"
	)
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)
	
	class Meta:
		verbose_name = "Message Action"
		verbose_name_plural = "Message Actions"
		ordering = ['-created_at']
	
	def __str__(self):
		return f"{self.action_type} - {self.action_status}"


class MessageAttachment(models.Model):
	"""
	Store file attachments associated with messages
	"""
	message = models.ForeignKey(
		Message,
		on_delete=models.CASCADE,
		related_name='attachments',
		help_text="The message this attachment is associated with"
	)
	file = models.FileField(
		upload_to='message_attachments/%Y/%m/%d/',
		help_text="Uploaded file"
	)
	filename = models.CharField(
		"Filename",
		max_length=255,
		help_text="Original filename"
	)
	content_type = models.CharField(
		"Content Type",
		max_length=100,
		blank=True,
		help_text="MIME type of the file"
	)
	file_size = models.IntegerField(
		"File Size",
		help_text="Size in bytes"
	)
	uploaded_at = models.DateTimeField(auto_now_add=True)
	
	class Meta:
		verbose_name = "Message Attachment"
		verbose_name_plural = "Message Attachments"
		ordering = ['uploaded_at']
	
	def __str__(self):
		return f"{self.filename} - {self.message}"

