from django.db import models
from .project import Project


class ContractingPlanning(models.Model):
	"""
	Store custom contracting requirements and uploaded documents
	"""
	project = models.OneToOneField(
		Project,
		on_delete=models.CASCADE,
		related_name='contracting_planning'
	)
	description = models.TextField(
		"Description",
		help_text="Description of specific contracting needs"
	)
	
	# AI-generated insights
	ai_summary = models.TextField(
		"AI Generated Summary",
		blank=True,
		null=True,
		help_text="AI-generated summary of the project"
	)
	ai_questions = models.JSONField(
		"AI Generated Questions",
		blank=True,
		null=True,
		help_text="Questions generated by AI to clarify requirements"
	)
	user_answers = models.JSONField(
		"User Answers",
		blank=True,
		null=True,
		help_text="User's answers to AI-generated questions"
	)
	selected_contractors = models.JSONField(
		"Selected Contractors",
		blank=True,
		null=True,
		help_text="Array of contractor IDs selected for invitation"
	)
	current_step = models.IntegerField(
		"Current Step",
		default=1,
		help_text="Current step in the contracting workflow (1-4)"
	)
	
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)

	class Meta:
		verbose_name = "Contracting Planning"
		verbose_name_plural = "Contracting Plannings"

	def __str__(self):
		return f"Planning for {self.project.name}"


class ContractingPlanningFile(models.Model):
	"""
	Store files uploaded for contracting planning
	"""
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='files'
	)
	file = models.FileField(
		upload_to='contracting_planning/%Y/%m/%d/',
		help_text="Uploaded document or photo"
	)
	filename = models.CharField(max_length=255)
	uploaded_at = models.DateTimeField(auto_now_add=True)

	class Meta:
		verbose_name = "Contracting Planning File"
		verbose_name_plural = "Contracting Planning Files"

	def __str__(self):
		return f"File for {self.contracting_planning.project.name}"


class SentEmail(models.Model):
	"""
	Track emails sent to contractors
	"""
	STATUS_CHOICES = [
		('pending', 'Pending'),
		('sent', 'Sent'),
		('failed', 'Failed'),
	]
	
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='sent_emails'
	)
	contractor_email = models.EmailField(
		"Contractor Email",
		help_text="Email address of the contractor"
	)
	subject = models.CharField(
		"Email Subject",
		max_length=500,
		help_text="Subject line of the email"
	)
	body_html = models.TextField(
		"Email Body HTML",
		help_text="HTML content of the email body"
	)
	sent_at = models.DateTimeField(
		"Sent At",
		auto_now_add=True,
		help_text="Timestamp when the email was sent"
	)
	gmail_message_id = models.CharField(
		"Gmail Message ID",
		max_length=255,
		blank=True,
		null=True,
		help_text="Message ID from Gmail API"
	)
	gmail_thread_id = models.CharField(
		"Gmail Thread ID",
		max_length=255,
		blank=True,
		null=True,
		help_text="Thread ID from Gmail API"
	)
	status = models.CharField(
		"Status",
		max_length=20,
		choices=STATUS_CHOICES,
		default='pending',
		help_text="Status of the email sending"
	)
	error_message = models.TextField(
		"Error Message",
		blank=True,
		null=True,
		help_text="Error message if sending failed"
	)
	
	class Meta:
		verbose_name = "Sent Email"
		verbose_name_plural = "Sent Emails"
		ordering = ['-sent_at']
	
	def __str__(self):
		return f"Email to {self.contractor_email} - {self.status}"


class Message(models.Model):
	"""
	Store conversation messages between user and AI agent for each contractor
	"""
	SENDER_CHOICES = [
		('user', 'User'),
		('ai', 'AI Agent'),
		('contractor', 'Contractor'),
	]
	
	MESSAGE_TYPE_CHOICES = [
		('user', 'User Message'),
		('ai', 'AI Response'),
		('ai_action_request', 'AI Action Request'),
		('ai_action_executed', 'AI Action Executed'),
	]
	
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='messages'
	)
	contractor_id = models.IntegerField(
		"Contractor ID",
		help_text="ID of the contractor this conversation is with"
	)
	sender = models.CharField(
		"Sender",
		max_length=20,
		choices=SENDER_CHOICES,
		help_text="Who sent this message"
	)
	message_type = models.CharField(
		"Message Type",
		max_length=30,
		choices=MESSAGE_TYPE_CHOICES,
		default='user',
		help_text="Type of message for rendering purposes"
	)
	content = models.TextField(
		"Message Content",
		help_text="The text content of the message"
	)
	timestamp = models.DateTimeField(
		"Timestamp",
		auto_now_add=True,
		help_text="When the message was sent"
	)
	is_read = models.BooleanField(
		"Is Read",
		default=False,
		help_text="Whether the message has been read by the user"
	)
	read_at = models.DateTimeField(
		"Read At",
		null=True,
		blank=True,
		help_text="When the message was marked as read"
	)
	
	class Meta:
		verbose_name = "Message"
		verbose_name_plural = "Messages"
		ordering = ['timestamp']
		indexes = [
			models.Index(fields=['contracting_planning', 'contractor_id', 'timestamp']),
		]
	
	def __str__(self):
		return f"{self.sender} message to contractor {self.contractor_id} at {self.timestamp}"


class MessageAction(models.Model):
	"""
	Store actions that AI agent wants to perform on behalf of the user
	"""
	ACTION_TYPE_CHOICES = [
		('send_email', 'Send Email'),
		('draft_email', 'Draft Email'),
		('fetch_email', 'Fetch Email'),
		('analyze_offer', 'Analyze Offer'),
		('compare_offers', 'Compare Offers'),
	]
	
	ACTION_STATUS_CHOICES = [
		('pending', 'Pending User Approval'),
		('approved', 'Approved'),
		('rejected', 'Rejected'),
		('executed', 'Executed'),
		('failed', 'Failed'),
	]
	
	message = models.OneToOneField(
		Message,
		on_delete=models.CASCADE,
		related_name='action',
		help_text="The message this action is associated with"
	)
	action_type = models.CharField(
		"Action Type",
		max_length=20,
		choices=ACTION_TYPE_CHOICES,
		help_text="Type of action to perform"
	)
	action_status = models.CharField(
		"Action Status",
		max_length=20,
		choices=ACTION_STATUS_CHOICES,
		default='pending',
		help_text="Current status of the action"
	)
	action_data = models.JSONField(
		"Action Data",
		help_text="Action-specific data (e.g., email subject, body, recipient)"
	)
	action_summary = models.TextField(
		"Action Summary",
		help_text="Human-readable summary for conversation context"
	)
	execution_result = models.JSONField(
		"Execution Result",
		blank=True,
		null=True,
		help_text="Results after action execution (e.g., Gmail message_id)"
	)
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)
	
	class Meta:
		verbose_name = "Message Action"
		verbose_name_plural = "Message Actions"
		ordering = ['-created_at']
	
	def __str__(self):
		return f"{self.action_type} - {self.action_status}"


class MessageAttachment(models.Model):
	"""
	Store file attachments associated with messages
	"""
	message = models.ForeignKey(
		Message,
		on_delete=models.CASCADE,
		related_name='attachments',
		help_text="The message this attachment is associated with"
	)
	file = models.FileField(
		upload_to='message_attachments/%Y/%m/%d/',
		help_text="Uploaded file"
	)
	filename = models.CharField(
		"Filename",
		max_length=255,
		help_text="Original filename"
	)
	content_type = models.CharField(
		"Content Type",
		max_length=100,
		blank=True,
		help_text="MIME type of the file"
	)
	file_size = models.IntegerField(
		"File Size",
		help_text="Size in bytes"
	)
	uploaded_at = models.DateTimeField(auto_now_add=True)
	
	class Meta:
		verbose_name = "Message Attachment"
		verbose_name_plural = "Message Attachments"
		ordering = ['uploaded_at']
	
	def __str__(self):
		return f"{self.filename} - {self.message}"


class ContractorOffer(models.Model):
	"""
	Store extracted offer data from contractors
	"""
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='offers',
		help_text="The contracting planning this offer is for"
	)
	contractor_id = models.IntegerField(
		"Contractor ID",
		null=True,
		blank=True,
		help_text="ID of the contractor who made this offer"
	)
	gmail_message_id = models.CharField(
		"Gmail Message ID",
		max_length=255,
		unique=True,
		null=True,
		blank=True,
		help_text="Link to the email containing this offer"
	)
	
	# Extracted structured data (comprehensive fields)
	total_price = models.DecimalField(
		"Total Price",
		max_digits=12,
		decimal_places=2,
		null=True,
		blank=True,
		help_text="Total offer price"
	)
	currency = models.CharField(
		"Currency",
		max_length=3,
		default='EUR',
		null=True,
		blank=True,
		help_text="Currency code (ISO 4217)"
	)
	timeline_start = models.DateField(
		"Timeline Start",
		null=True,
		blank=True,
		help_text="Proposed project start date"
	)
	timeline_end = models.DateField(
		"Timeline End",
		null=True,
		blank=True,
		help_text="Proposed project end date"
	)
	timeline_duration_days = models.IntegerField(
		"Timeline Duration (Days)",
		null=True,
		blank=True,
		help_text="Project duration in days"
	)
	
	# Detailed breakdown
	scope_of_work = models.TextField(
		"Scope of Work",
		null=True,
		blank=True,
		help_text="Description of work to be performed"
	)
	materials_included = models.JSONField(
		"Materials Included",
		default=list,
		blank=True,
		help_text="List of materials included in the offer"
	)
	labor_breakdown = models.JSONField(
		"Labor Breakdown",
		default=dict,
		blank=True,
		help_text="Cost breakdown by labor type"
	)
	payment_terms = models.TextField(
		"Payment Terms",
		null=True,
		blank=True,
		help_text="Payment terms and conditions"
	)
	payment_schedule = models.JSONField(
		"Payment Schedule",
		default=list,
		blank=True,
		help_text="Payment milestones and amounts"
	)
	
	# Additional details
	warranty_period = models.CharField(
		"Warranty Period",
		max_length=100,
		null=True,
		blank=True,
		help_text="Warranty period (e.g., '2 years')"
	)
	warranty_details = models.TextField(
		"Warranty Details",
		null=True,
		blank=True,
		help_text="Detailed warranty information"
	)
	insurance_details = models.TextField(
		"Insurance Details",
		null=True,
		blank=True,
		help_text="Insurance coverage information"
	)
	special_conditions = models.TextField(
		"Special Conditions",
		null=True,
		blank=True,
		help_text="Any special conditions or notes"
	)
	misc_details = models.JSONField(
		"Miscellaneous Details",
		default=dict,
		blank=True,
		help_text="Additional information not captured in other fields (e.g., project manager, certifications, references)"
	)
	
	# Metadata
	offer_date = models.DateField(
		"Offer Date",
		null=True,
		blank=True,
		help_text="Date the offer was made"
	)
	valid_until = models.DateField(
		"Valid Until",
		null=True,
		blank=True,
		help_text="Date until which the offer is valid"
	)
	extracted_data = models.JSONField(
		"Extracted Data",
		default=dict,
		blank=True,
		help_text="Full extracted JSON for flexibility"
	)
	pdf_attachment_id = models.CharField(
		"PDF Attachment ID",
		max_length=255,
		null=True,
		blank=True,
		help_text="Gmail attachment ID if offer was in PDF"
	)
	email_received_at = models.DateTimeField(
		"Email Received At",
		null=True,
		blank=True,
		help_text="Timestamp when the offer email was received in Gmail"
	)
	
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)
	
	class Meta:
		verbose_name = "Contractor Offer"
		verbose_name_plural = "Contractor Offers"
		ordering = ['-email_received_at', '-created_at']
		indexes = [
			models.Index(fields=['contracting_planning', 'contractor_id']),
			models.Index(fields=['gmail_message_id']),
			models.Index(fields=['email_received_at']),
		]
	
	def __str__(self):
		contractor_text = f"Contractor {self.contractor_id}"
		price_text = f"â‚¬{self.total_price}" if self.total_price else "Price TBD"
		return f"Offer from {contractor_text} - {price_text}"


class OfferAnalysis(models.Model):
	"""
	Store analysis reports for offers
	"""
	ANALYSIS_TYPE_CHOICES = [
		('single', 'Single Offer Analysis'),
		('comparison', 'Offer Comparison'),
	]
	
	offer = models.ForeignKey(
		ContractorOffer,
		on_delete=models.CASCADE,
		related_name='analyses',
		help_text="The primary offer being analyzed"
	)
	analysis_type = models.CharField(
		"Analysis Type",
		max_length=20,
		choices=ANALYSIS_TYPE_CHOICES,
		help_text="Type of analysis performed"
	)
	
	# Analysis content
	analysis_report = models.TextField(
		"Analysis Report",
		help_text="Markdown formatted analysis report"
	)
	analysis_data = models.JSONField(
		"Analysis Data",
		default=dict,
		blank=True,
		help_text="Structured analysis data for programmatic access"
	)
	
	# Comparison specific
	compared_offer_ids = models.JSONField(
		"Compared Offer IDs",
		default=list,
		blank=True,
		help_text="List of offer IDs compared (if type='comparison')"
	)
	
	# RAG metadata (for future)
	documents_used = models.JSONField(
		"Documents Used",
		default=list,
		blank=True,
		null=True,
		help_text="List of document IDs used in RAG pipeline"
	)
	embeddings_version = models.CharField(
		"Embeddings Version",
		max_length=50,
		null=True,
		blank=True,
		help_text="Version of embeddings model used"
	)
	
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)
	
	class Meta:
		verbose_name = "Offer Analysis"
		verbose_name_plural = "Offer Analyses"
		ordering = ['-created_at']
		indexes = [
			models.Index(fields=['offer', 'analysis_type']),
		]
	
	def __str__(self):
		return f"{self.get_analysis_type_display()} for {self.offer}"


class ProcessedEmail(models.Model):
	"""
	Track emails that have been processed by the background monitoring task.
	Helps prevent duplicate processing and provides audit trail.
	"""
	gmail_message_id = models.CharField(
		"Gmail Message ID",
		max_length=255,
		unique=True,
		db_index=True,
		help_text="Unique Gmail message ID to prevent reprocessing"
	)
	contractor_id = models.IntegerField(
		"Contractor ID",
		help_text="ID of the contractor who sent the email"
	)
	contracting_planning = models.ForeignKey(
		ContractingPlanning,
		on_delete=models.CASCADE,
		related_name='processed_emails',
		help_text="The contracting planning this email belongs to"
	)
	email_subject = models.CharField(
		"Email Subject",
		max_length=500,
		blank=True,
		help_text="Subject line of the email"
	)
	email_received_at = models.DateTimeField(
		"Email Received At",
		null=True,
		blank=True,
		help_text="When the email was received in Gmail"
	)
	processed_at = models.DateTimeField(
		"Processed At",
		auto_now_add=True,
		help_text="When the email was processed by our system"
	)
	created_offer = models.ForeignKey(
		ContractorOffer,
		on_delete=models.SET_NULL,
		null=True,
		blank=True,
		related_name='source_processed_email',
		help_text="The offer created from this email (if any)"
	)
	created_message = models.ForeignKey(
		Message,
		on_delete=models.SET_NULL,
		null=True,
		blank=True,
		related_name='source_processed_email',
		help_text="The system message created for this email"
	)
	
	class Meta:
		verbose_name = "Processed Email"
		verbose_name_plural = "Processed Emails"
		ordering = ['-processed_at']
		indexes = [
			models.Index(fields=['contracting_planning', 'contractor_id']),
			models.Index(fields=['gmail_message_id']),
			models.Index(fields=['processed_at']),
		]
	
	def __str__(self):
		return f"Email from contractor {self.contractor_id} processed at {self.processed_at}"

